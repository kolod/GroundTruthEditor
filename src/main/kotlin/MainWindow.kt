package io.github.kolod

import com.formdev.flatlaf.FlatLightLaf
import com.jcabi.manifests.Manifests
import net.sourceforge.tess4j.Tesseract
import net.sourceforge.tess4j.util.LoadLibs
import java.awt.*
import java.io.File
import java.io.FileNotFoundException
import java.util.*
import java.util.prefs.Preferences
import javax.swing.*
import javax.swing.JFileChooser.*


class MainWindow : JFrame() {
	private val bundle = ResourceBundle.getBundle("i18n/GroundTruthEditor")
	private val prefs = Preferences.userNodeForPackage(MainWindow::class.java)
	private var tesseract = Tesseract()
	private val list = mutableListOf<File>()
	private var current : Int = -1
	private var directory :File? = null

	private val mainMenuBar               = JMenuBar()
	private val menuFile                  = JMenu()
	private val menuEdit                  = JMenu()

	private val openFolder                = JMenuItem()
	private val reload                    = JMenuItem()
	private val renumber                  = JMenuItem()
	private val removeDuplicates          = JMenuItem()
	private val markAllUnfinished         = JMenuItem()
	private val next                      = JMenuItem()
	private val nextUnfinished            = JMenuItem()
	private val previous                  = JMenuItem()
	private val previousUnfinished        = JMenuItem()
	private val first                     = JMenuItem()
	private val last                      = JMenuItem()
	private val markAsFinished            = JMenuItem()
	private val markAsFinishedAndNext     = JMenuItem()
	private val markAsUnfinished          = JMenuItem()
	private val delete                    = JMenuItem()
	private val spellCheck                = JMenuItem()

	private val imageView                 = JLabel()
	private val imageViewScroll           = JScrollPane(imageView)
	private val textView                  = JEditorPane()
	private val textViewScroll            = JScrollPane(textView)
	private val rawTextView               = JTextArea()
	private val rawTextViewScroll         = JScrollPane(rawTextView)

	private fun initTesseract() {
		logger.trace("Tesseract initialization started.")
		tesseract.setDatapath(LoadLibs.extractTessResources("tessdata").path)
		tesseract.setLanguage("rus+lat")
		tesseract.setVariable("user_defined_dpi", "96")
		tesseract.setVariable("tessedit_create_hocr", "0")
	}

	private fun loadIcons(name :String, extension :String = "png") :List<Image> {
		val toolkit = Toolkit.getDefaultToolkit()
		return listOf(16, 24, 32, 48, 64, 72, 96, 128, 256).map{ size ->
			"$name$size.$extension"
		}.mapNotNull{ path ->
			javaClass.classLoader.getResource(path)
		}.mapNotNull{ url ->
			try {
				toolkit.createImage(url)
			} catch (ex: Exception) {
				logger.warn(ex.message, ex)
				null
			}
		}
	}

	private fun updateTitle() {
		title = bundle.getString("title") + " " + Manifests.read("Build-Date") +
			(list.getOrNull(current)?.fileName?.let { " [$it]" } ?: "")
	}

	private fun translateUI() {
		updateTitle()
		with(bundle) {
			menuFile.text                  = getString("file_menu")
			menuEdit.text                  = getString("file_edit")
			openFolder.text                = getString("menu_open")
			reload.text                    = getString("menu_reload")
			renumber.text                  = getString("menu_renumber")
			removeDuplicates.text          = getString("menu_remove_duplicates")
			markAllUnfinished.text         = getString("menu_mark_all_unfinished")
			spellCheck.text                = getString("menu_spell_check")
			next.text                      = getString("menu_next")
			nextUnfinished.text            = getString("menu_next_unfinished")
			previous.text                  = getString("menu_previous")
			previousUnfinished.text        = getString("menu_previous_unfinished")
			first.text                     = getString("menu_first")
			last.text                      = getString("menu_last")
			markAsFinished.text            = getString("menu_mark_as_finished")
			markAsFinishedAndNext.text     = getString("menu_mark_as_finished_and_next")
			markAsUnfinished.text          = getString("menu_mark_as_unfinished")
			delete.text                    = getString("menu_delete")
		}
	}

	/**
	 * This method is called from within the constructor to initialize the form. WARNING: Do NOT modify this code. The
	 * content of this method is always regenerated by the Form Editor.
	 */
	private fun initComponents() {
		preferredSize = Dimension(1200, 600)
		defaultCloseOperation = EXIT_ON_CLOSE
		iconImages = loadIcons("icon/")
		rawTextView.isEditable = false

		translateUI()

		with(menuFile) {
			add(openFolder)
			addSeparator()
			add(renumber)
			add(removeDuplicates)
			add(spellCheck)
			add(markAllUnfinished)
		}

		with (menuEdit) {
			add(previous)
			add(next)
			addSeparator()
			add(previousUnfinished)
			add(nextUnfinished)
			addSeparator()
			add(first)
			add(last)
			addSeparator()
			add(markAsUnfinished)
			add(markAsFinished)
			add(markAsFinishedAndNext)
			addSeparator()
			add(delete)
		}

		with (mainMenuBar) {
			add(menuFile)
			add(menuEdit)
		}

		jMenuBar = mainMenuBar

		val splitter1 = JSplitPane(JSplitPane.VERTICAL_SPLIT, rawTextViewScroll, textViewScroll)
		val splitter2 = JSplitPane(JSplitPane.VERTICAL_SPLIT, imageViewScroll, splitter1)

		contentPane.add(splitter2, BorderLayout.CENTER)

		pack()
		setLocationRelativeTo(null)
		splitter2.dividerLocation = splitter2.height / 2
		splitter1.dividerLocation = splitter1.height / 2
	}

	private fun save() = try {
		list.getOrNull(current)?.let { file ->
			File(directory, file.fileName + ".gt.txt").let { finished ->
				finished.writeText(textView.plainText)
				logger.debug("Save: ${finished.absolutePath}")
			}
		}
	} catch (ex :Exception) {
		logger.error(ex.message, ex)
	}

	private fun loadText(image : File) = try {
		File(directory, image.nameWithoutExtension + ".gt.txt").readText().ifBlank { null }
	} catch (ex : FileNotFoundException) {
		null
	} catch (ex : Exception) {
		logger.error(ex.message, ex)
		null
	}

	private fun load(id : Int) {
		current = id
		list.getOrNull(current)?.let { imageFile ->
			val image = preProcessImage(imageFile)
			val text = loadText(imageFile)
			imageView.icon = ImageIcon(image)
			rawTextView.text = tesseract.doOCR(image)
			textView.setPlainText( text ?: rawTextView.text )
		} ?: run {
			imageView.icon = null
			rawTextView.text = ""
			textView.setPlainText("")
		}
		updateTitle()
	}

	private fun next() = if (current + 1 < list.size) { current += 1; load(current) } else logger.info("Last file.")
	private fun previous() = if (current > 0) { current -= 1; load(current) } else logger.info("First file.")

	private fun loadFolder() {
		list.clear()
		directory?.walk()?.filter { it.isFile && it.path.endsWith(".png") }?.let { list.addAll( it ) }
		load(if (list.size > 0) 0 else -1)
	}

	/**
	 * Creates new form TestTrainer
	 */
	init {
		logger.info("Application started")
		initComponents()
		initTesseract()

		prefs.get("directory", null)?.let { it ->
			directory = File(it)
			loadFolder()
		}

		removeDuplicates.addActionListener {
			directory?.deleteDuplicatesWithCompanions(".*\\.png".toRegex())?.forEach { file ->
				logger.debug("Removed: ${file.absolutePath}")
			}
		}

		renumber.addActionListener {
			directory?.renumberWithCompanions(""".*\.png""")
		}

		markAllUnfinished.addActionListener {
			directory?.list { _, filename ->
				filename.endsWith(".gt.txt")
			}?.mapNotNull { name ->
				File(directory, name).renameTo( File(directory, name.split(".").first() + ".txt"))
			}
		}

		delete.addActionListener {
			list.getOrNull(current)?.let { file ->
				file.getCompanions().forEach { it.delete() }
				list.remove(file)
				load(maxOf(current, list.size - 1))
			}
		}

		openFolder.addActionListener {
			val dialog = JFileChooser()
			dialog.fileSelectionMode = DIRECTORIES_ONLY
			dialog.isMultiSelectionEnabled = false
			dialog.selectedFile = directory
			if (dialog.showOpenDialog(this) == APPROVE_OPTION) {
				directory = dialog.selectedFile
				directory?.absolutePath?.let { path ->
					prefs.put("directory", path)
					logger.info("Directory: $path")
					loadFolder()
				}
			}
		}

		reload.addActionListener {
			loadFolder()
		}

		spellCheck.addActionListener {
			logger.info( directory?.getAllSpellCheckErrors()?.toSet()?.joinToString() ?: "none")
		}

		markAsFinished.addActionListener { save() }
		next.addActionListener { next() }
		previous.addActionListener { previous() }
		first.addActionListener { load(if (list.size > 0) 0 else -1) }
		last.addActionListener { load(if (list.size > 0) list.size - 1 else -1) }
		markAsFinishedAndNext.addActionListener { save(); next() }
	}

	companion object {
		/**
		 * @param args the command line arguments
		 */
		@JvmStatic
		fun main(args: Array<String>) {
			FlatLightLaf.setup()
			UIManager.put("defaultFont", UIManager.getFont("defaultFont")/*.deriveFont(14f)*/)
			SwingUtilities.invokeLater { MainWindow().isVisible = true }
		}
	}
}
