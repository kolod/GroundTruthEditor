package io.github.kolod

import com.formdev.flatlaf.FlatLightLaf
import com.jcabi.manifests.Manifests
import org.slf4j.LoggerFactory
import java.awt.*
import java.awt.event.ItemEvent.*
import java.io.File
import java.util.*
import java.util.prefs.Preferences
import javax.imageio.ImageIO
import javax.swing.*
import javax.swing.JFileChooser.*


class GroundTruthEditor : JFrame() {
	enum class FinishedState {UNFINISHED, ANY}

	private val logger = LoggerFactory.getLogger(GroundTruthEditor::class.java)
	private val bundle = ResourceBundle.getBundle("i18n/GroundTruthEditor")
	private val prefs = Preferences.userNodeForPackage(GroundTruthEditor::class.java)
	private var directory :File? = null
	private var id = 1

	private val imageView                 = JLabel()
	private val imageViewScroll           = JScrollPane(imageView)
	private val textView                  = JTextArea()
	private val textViewScroll            = JScrollPane(textView)

	private val renumberButton            = JButton()
	private val removeDuplicatesButton    = JButton()
	private val uncheckAllButton          = JButton()
	private val browseButton              = JButton()

	private val previousButton            = JButton()
	private val previousUnfinishedButton  = JButton()
	private val doneButton                = JToggleButton()
	private val doneAndNextButton         = JButton()
	private val nextButton                = JButton()
	private val nextUnfinishedButton      = JButton()


	private fun loadIcons(name :String, extension :String = "png") :List<Image> {
		val toolkit = Toolkit.getDefaultToolkit()
		return listOf(16, 24, 32, 48, 64, 72, 96, 128, 256).map{ size ->
			"$name$size.$extension"
		}.mapNotNull{ path ->
			javaClass.classLoader.getResource(path)
		}.mapNotNull{ url ->
			try {
				toolkit.createImage(url)
			} catch (ex: Exception) {
				logger.warn(ex.message, ex)
				null
			}
		}
	}

	private fun translateUI() {
		with(bundle) {
			title                       = getString("title") + " " + Manifests.read("Build-Date")
			nextButton.text             = getString("next_button")
			previousButton.text         = getString("previous_button")
			checkButton.text            = getString("check_button")
			browseButton.text           = getString("browse_button")
			uncheckAllButton.text       = getString("uncheck_all_button")
			removeDuplicatesButton.text = getString("remove_duplicates_button")
			renumberButton.text         = getString("renumber_button")
			checkAndNextUnchecked       = getString("next_button")

			checkButton.addItemListener { event ->
				checkButton.text = when (event.stateChange) {
					SELECTED   -> getString("uncheck_button")
					DESELECTED -> getString("check_button")
					else -> ""
				}
			}
		}
	}

	/**
	 * This method is called from within the constructor to initialize the form. WARNING: Do NOT modify this code. The
	 * content of this method is always regenerated by the Form Editor.
	 */
	private fun initComponents() {
		preferredSize = Dimension(1200, 600)
		defaultCloseOperation = EXIT_ON_CLOSE
		iconImages = loadIcons("icon/")

		translateUI()

		val splitter = JSplitPane(JSplitPane.VERTICAL_SPLIT, imageViewScroll, textViewScroll)

		val header = JPanel(FlowLayout(FlowLayout.CENTER)).apply {
			add(renumberButton)
			add(removeDuplicatesButton)
			add(uncheckAllButton)
			add(browseButton)
		}

		val footer = JPanel(FlowLayout(FlowLayout.CENTER)).apply {
			add(previousButton)
			add(previousUnfinishedButton)
			add(doneButton)
			add(doneAndNextButton)
			add(nextButton)
			add(nextUnfinishedButton)
		}

		with (contentPane) {
			add(header, BorderLayout.NORTH)
			add(splitter, BorderLayout.CENTER)
			add(footer, BorderLayout.SOUTH)
		}

		pack()
		setLocationRelativeTo(null)
		splitter.dividerLocation = splitter.height / 2
	}

	private fun stringID() :String = id.toString().padStart(4, '0')

	private fun open(newId :Int, finished :FinishedState) :Boolean = try {
		id = newId
		val idStr = stringID()
		val pngFile = File(directory, "$idStr.png")
		val txtCheckedFile = File(directory, "$idStr.gt.txt")
		val txtUncheckedFile = File(directory, "$idStr.txt")

		when (state) {
			FinishedState.UNFINISHED ->
				if (txtUncheckedFile.exists()) {
					checkButton.isSelected = false
					textView.text = txtUncheckedFile.readText()
					imageView.icon = ImageIcon(ImageIO.read(pngFile))
					true
				} else false

			FinishedState.ANY ->
				if (txtCheckedFile.exists() -> {
					doneButton.isSelected = true
					textView.text = txtCheckedFile.readText()
					true
				} else if (txtUncheckedFile.exists()) {
					checkButton.isSelected = false
					textView.text = txtUncheckedFile.readText()
					imageView.icon = ImageIcon(ImageIO.read(pngFile))
					true
				} else false
			}
		}

	} catch (ex :Exception) {
		//logger.error(ex.message, ex)
		false
	}

	private fun save(checked :Boolean) = try {
		val idStr = stringID()
		val txtCheckedFile = File(directory, "$idStr.gt.txt")
		val txtUncheckedFile = File(directory, "$idStr.txt")
		if (checked) {
			logger.debug("Save: ${txtCheckedFile.absolutePath}")
			txtCheckedFile.writeText(textView.text)
			txtUncheckedFile.delete()
		} else {
			logger.debug("Save: ${txtUncheckedFile.absolutePath}")
			txtUncheckedFile.writeText(textView.text)
			txtCheckedFile.delete()
		}
	} catch (ex :Exception) {
		logger.error(ex.message, ex)
	}

	fun next(finished :FinishedState) :Boolean {
		for (i in id + 1 .. 9999) {
			if (open(i), finished) break
		}
	}

	fun previous(finished :FinishedState) :Boolean {
		for (i in id - 1 downTo 1) {
			if (open(i), finished) break
		}
	}

	/**
	 * Creates new form TestTrainer
	 */
	init {
		logger.info("Application started")
		initComponents()

		prefs.get("directory", null)?.let {
			directory = File(it)
		}

		removeDuplicatesButton.addActionListener {
			directory?.deleteDuplicatesWithCompanions(".*\\.png".toRegex())?.forEach { file ->
				logger.debug("Removed: ${file.absolutePath}")
			}
		}

		renumberButton.addActionListener {
			directory?.renumberWithCompanions(".*\\.png".toRegex())
		}

		uncheckAllButton.addActionListener {
			directory?.list { _, filename ->
				filename.endsWith(".gt.txt")
			}?.mapNotNull { name ->
				File(directory, name).renameTo( File(directory, name.split(".").first() + ".txt"))
			}
		}

		browseButton.addActionListener {
			val dialog = JFileChooser()
			dialog.fileSelectionMode = DIRECTORIES_ONLY
			dialog.isMultiSelectionEnabled = false
			dialog.selectedFile = directory
			if (dialog.showOpenDialog(this) == APPROVE_OPTION) directory = dialog.selectedFile
			directory?.absolutePath?.let { path ->
				prefs.put("directory", path)
				logger.info("Directory: $path")
				for (i in id + 1 .. 9999) {
					if (open(i)) break
				}
			}
		}

		doneButton.addActionListener { event ->
			(event.source as? JToggleButton)?.let{ button ->
				save(button.model.isSelected)
			}
		}

		doneAndNextButton.addActionListener { event ->
			save(true)
			next(FinishedState.FINISHED)
		}

		nextButton.addActionListener { next(FinishedState.ANY) }
		nextUnfinishedButton.addActionListener { next(FinishedState.UNFINISHED) }

		previousButton.addActionListener{ previous(FinishedState.ANY) }
		previousUnfinishedButton.addActionListener{ previous(FinishedState.UNFINISHED) }

		previousButton.addActionListener {
			for (i in id - 1 downTo 1) {
				if (open(i)) break
			}
		}
	}

	companion object {
		/**
		 * @param args the command line arguments
		 */
		@JvmStatic
		fun main(args: Array<String>) {
			FlatLightLaf.setup()
			UIManager.put("defaultFont", UIManager.getFont("defaultFont").deriveFont(14f))
			SwingUtilities.invokeLater { GroundTruthEditor().isVisible = true }
		}
	}
}
